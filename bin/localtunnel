#!/usr/bin/env ruby
require 'rubygems'
require 'net/ssh'
require 'net/ssh/gateway'
require 'net/http'
require 'uri'
require 'optparse'
require 'json'

require 'lib/gateway'

key = nil
options = OptionParser.new do |o|
  o.banner = "Usage: localtunnel [options] <localport>"
  o.on("-k", "--key FILE", "upload a public key for authentication") do |k|
    key = File.exist?(k.to_s) ? File.open(k).read : nil
  end
  o.on('-h', "--help", "show this help") { puts o; exit }
end
args = options.parse!
local_port = args[0]
unless local_port
  puts options
  exit
end

def register_tunnel(key=nil)
  url = URI.parse("http://open.localtunnel.com/")
  if key
    return JSON.parse(Net::HTTP.post_form(url, {"key" => key}).body)
  else
    return JSON.parse(Net::HTTP.get(url))
  end
end

def start_tunnel(port, tunnel)
  gateway = Net::SSH::Gateway.new(tunnel['host'], tunnel['user'])
  gateway.open_remote(port.to_i, '127.0.0.1', tunnel['through_port'].to_i) do |a,b|
    puts tunnel['banner'] if tunnel.has_key? 'banner'
    puts "Port #{port} is now publicly accessible from http://#{tunnel['host']} ..."
    begin
      sleep 1 while true
    rescue Interrupt
      exit
    end
  end
end

begin
  start_tunnel(local_port, register_tunnel(key))
rescue Net::SSH::AuthenticationFailed
  possible_key = Dir[File.expand_path('~/.ssh/*.pub')].first
  puts "Failed to authenticate. If this is your first tunnel, you need to"
  puts "upload a public key using the -k option. Try this:\n"
  puts "localtunnel -k #{possible_key ? possible_key : '~/path/to/key'} #{local_port}"
end

